You are working inside an existing Python trading system called maxtrader.
maxtrader already has:


A Position model that tracks open options positions (legs, quantities, average price, etc.).


A Portfolio / Risk module that provides:


Account equity


Open risk per position




A MarketData / OptionChain layer for:


Latest option quotes (bid/ask/mid, greeks)


Underlying price


Days to expiration (DTE)




An Order / Execution layer that can:


Submit multi-leg orders (spreads, single-leg orders)


Simulate or execute fills




Your task is to:

Implement a fly exit module for maxtrader that:


Handles Henry Gambell–style Unbalanced Butterflies (UBFly)


Handles existing balanced regular butterflies


Never exits via full-fly combo


Always exits via split verticals + wings, to avoid MM games, wide fly bid/ask, and fill problems.



The goal is execution- and slippage-aware exits, not entry logic.

1. Integration Constraints
Assume the following exist (or can be easily adapted):


Position object:


Has:


.id


.underlying


.legs → list of Leg (each with contract, qty, side)


.meta / .tags dict with strategy metadata


.entry_price or .entry_credit


.opened_at


.expiry or .expiration






Leg:


.contract (includes symbol, strike, right, expiry)


.quantity (positive long, negative short)




OptionChain:


Can give you latest OptionQuote for any contract in the position.




Utility functions:


get_dte(position) → int


get_underlying_price(position) → float


calculate_position_value(position, chain) → float (current net value per 1 “fly unit”)


calculate_pnl(position, chain) → float (realized + unrealized)




Order execution layer:


submit_spread(order_legs, tag, time_in_force)


submit_single_leg(order_leg, tag, time_in_force)


You do not need to wire to a real broker; just assume a function that accepts lists of legs and tags.




If something doesn’t exist exactly like this, write adapter functions or minimal wrappers.

2. New Module: fly_exit.py
Create a module fly_exit.py in maxtrader with:


A config object for fly exits


A FlyExitEngine class with:


Public method:
def evaluate_and_build_exits(
    self,
    position: Position,
    chain: OptionChain,
    now: datetime
) -> list[OrderSpec]:
    """
    Given an open butterfly position and current market data,
    return a list of OrderSpec objects describing how to exit
    or adjust this position (if any action is required).
    """





OrderSpec can be:
@dataclass
class OrderSpec:
    legs: list[ExitLeg]  # each ExitLeg has contract, qty, side
    tag: str             # e.g. "EXIT_UBFLY_BODY", "EXIT_UBFLY_WINGS"
    time_in_force: str   # e.g. "DAY", "IOC"

If maxtrader already has an order spec type, use that instead.

3. Configuration for Exits
In fly_exit.py, define a FlyExitConfig dataclass (or use existing config system):
@dataclass
class FlyExitConfig:
    base_profit_target: float = 0.60      # capture 60% of entry credit
    max_loss_fraction: float = 0.50      # lose at most 50% of per-fly risk
    min_credit_before_final_days: float = 0.30
    pin_zone_fraction: float = 0.30      # within 30% of wing width around body
    far_zone_fraction: float = 0.75      # >75% of wing width away = “far”
    pin_profit_multiple: float = 2.0     # 2x entry credit for pin exits
    rail_buffer_fraction: float = 0.10   # 10% of wing width beyond low wing
    wing_close_threshold: float = 0.05   # min value to justify closing wings
    scale_out_fraction: float = 0.50     # if >1 fly, close this fraction at base profit

Use this config inside FlyExitEngine.

4. Recognizing Fly Types from Existing Positions
Your positions already exist. We want to identify:


structure_type:


"UBFLY" → Henry-style unbalanced fly (e.g. 1:-3:+2)


"BALANCED_FLY" → regular 1:-2:+1 butterflies




And compute:


K_low, K_body, K_high (strikes)


W (wing width) = |K_body - K_low| (assume symmetric for now)


Count of legs at each strike and side (long/short).




Implement helpers in fly_exit.py:
def classify_fly_structure(position: Position) -> dict:
    """
    Inspect legs and return:
    {
      "structure_type": "UBFLY" | "BALANCED_FLY" | "UNKNOWN",
      "K_low": float,
      "K_body": float,
      "K_high": float,
      "W": float,
      "leg_map": { (strike, right): {"long": int, "short": int} }
    }
    """

Primary detection:


UBFly (Henry): put side, ratio approx +1 @ high, -3 @ body, +2 @ low.


Balanced fly: either calls or puts, ratio +1 @ low, -2 @ body, +1 @ high.


If structure is "UNKNOWN", FlyExitEngine should just return [] (no exit suggestions).

5. Core Exit Logic – Shared Skeleton
Inside FlyExitEngine.evaluate_and_build_exits:


Get DTE, underlying price, current value, PnL, entry_credit, and risk_per_fly (if not in meta, compute as W - entry_credit for credit flies).


Use classify_fly_structure(position) to get structure details.


Apply same decision order for both UBFly and balanced fly:


(1) Loss-cut / rail protection


(2) Base profit capture


(3) Time-based give-up


(4) Pin profit in last 1–2 DTE


(5) Expiry-day assignment avoider (DTE = 0)




But how the exit is implemented (legs) depends on structure type (UBFLY vs BALANCED_FLY).

6. Split Exit – Henry UBFly (1:-3:+2)
For "UBFLY":
Assume put UBFly with:


+1 long put @ K_high


-3 short puts @ K_body


+2 long puts @ K_low


6.1 Build Body Collapse as Vertical(s)
Implement:
def build_vertical_collapse_for_ubfly(
    position: Position,
    structure_info: dict
) -> list[ExitLeg]:
    """
    Build ExitLegs to collapse the short body of a UBFly using 
    vertical spreads only (no full-fly combo order).
    For puts:
      - Buy back shorts at K_body
      - Sell matching quantity at K_low
    """

Rules:


Derive how many shorts exist at K_body (ideally 3× per unit).


Derive how many longs exist at K_low.


Build verticals:


For each short at K_body, pair it with one long at K_low:


BUY_TO_CLOSE put @ K_body


SELL_TO_CLOSE put @ K_low






If there are extra longs at K_low beyond what’s needed to pair all shorts, leave them for wings logic.


6.2 Wing Exit for UBFly
After body collapse, remaining legs are pure longs:


+1 @ K_high (maybe)


+N @ K_low (maybe)


Implement:
def build_wing_exits_for_ubfly(
    position_after_body_collapse: Position,
    chain: OptionChain,
    cfg: FlyExitConfig
) -> list[ExitLeg]:
    """
    For each remaining pure long option:
      - If mark value >= cfg.wing_close_threshold: close
      - Else: allow to expire (no order)
    """

Logic:


If DTE ≤ 1 and wing is ITM, prefer to close to avoid unwanted exercise.


If DTE > 1 and value is small (< threshold), optional: leave (we’re mostly concerned with body risk).



7. Split Exit – Balanced Flies (1:-2:+1)
For "BALANCED_FLY" (put or call):
Example: put fly +1@K_low, -2@K_body, +1@K_high.
Implement:
def build_split_exit_for_balanced_fly(
    position: Position,
    structure_info: dict
) -> list[ExitLeg]:
    """
    Split a balanced fly into verticals to remove short body risk first,
    then close remaining longs.
    """

Strategy:


Identify the two verticals around body:


For put fly:


Vertical 1: long @ K_low, short @ K_body


Vertical 2: long @ K_high, short @ K_body


Exit steps:


Build vertical orders:


For each short at K_body, pair first with K_low longs, then with K_high longs (depending how your current position is structured).




This collapses all -2 body exposure via verticals.


If any extra longs remain (over-hedged wings), close them outright if value ≥ wing_close_threshold.


The result: no full-fly closure, just verticals + longs.

8. Decision Rules (When to Trigger Exits)
Use the config and apply in order:
8.1 Loss Cut / Rail
if pnl <= -config.max_loss_fraction * risk_per_fly * 100:
    # build split exit (body + wings) according to structure_type

AND/OR for UBFly:


If underlying_price <= K_low - rail_buffer_fraction * W:


Build split exit.




8.2 Base Profit (High-Prob Exit)
Let:


entry_credit = per-fly credit (for debit flies, treat as absolute)


current_value = mark value per fly


For credit fly: credit_captured = (entry_credit - current_value) / entry_credit


If:
credit_captured >= config.base_profit_target and DTE >= 2:
    if units > 1:
        # scale out fraction of position via split exit
    else:
        # full split exit

For scaling:


Determine units of fly in position (you’ll probably have a units concept already or infer from quantities).


If units > 1, close floor(units * scale_out_fraction) units using split exit logic.


Leave remainder to run for pin logic.


8.3 Time-based Give-Up
If:


2 <= DTE <= 3


credit_captured < config.min_credit_before_final_days


abs(underlying_price - K_body) > config.far_zone_fraction * W


→ full split exit.
8.4 Pin Profit (Last 1–2 DTE)
If:


DTE <= 1


abs(underlying_price - K_body) <= config.pin_zone_fraction * W


pnl >= config.pin_profit_multiple * entry_credit * 100


→ full split exit (body + wings).
8.5 Expiration-Day Assignment
If DTE == 0:


If any short leg is ITM, build body collapse verticals to remove shorts.


Then close any ITM longs if you don’t want stock, or let OTM wings expire.



9. Output: OrderSpecs Only
evaluate_and_build_exits should:


Not execute trades itself.


Only return a list of OrderSpec objects describing the desired legs:


For UBFly:


1+ OrderSpec for body verticals


0+ OrderSpec for wing closures




For balanced fly:


1+ OrderSpec for body verticals


0+ OrderSpec for remaining wings






Elsewhere in maxtrader:


The execution layer consumes OrderSpecs:


Applies limit/mid-price logic


Handles slippage


Submits to broker / simulator





10. Testing & Safety
Add tests (or at least a debug_fly_exit() harness) that:


Create synthetic positions representing:


A Henry UBFly 1:-3:+2


A balanced fly 1:-2:+1




Mimic various scenarios:


PnL at small win


PnL at large win near pin


Big loser (underlying blew through wings)


Last-day ITM shorts




Confirm:


classify_fly_structure() labels them correctly.


Exit engine returns split vertical + wing orders, never a full-fly combo.


The correct legs and quantities are generated.





Deliverable:
Produce fly_exit.py (plus any small changes to existing types) integrated with maxtrader, with:


FlyExitConfig


classify_fly_structure


FlyExitEngine and its helper methods:


build_vertical_collapse_for_ubfly


build_wing_exits_for_ubfly


build_split_exit_for_balanced_fly




A small example or test harness in if __name__ == "__main__": to demonstrate behavior.


Focus on:


Robustness in edge cases


Clear comments


Zero use of full-fly combo exits



That’s the full prompt. If you want, once Replit spits out a first version, paste fly_exit.py back here and I’ll help you tighten the logic and align it exactly with how you want maxtrader to behave in live trading.