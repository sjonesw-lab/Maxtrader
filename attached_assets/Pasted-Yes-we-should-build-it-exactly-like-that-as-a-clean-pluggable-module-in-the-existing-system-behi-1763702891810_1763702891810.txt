Yes, we should build it exactly like that: as a clean, pluggable module in the existing system, behind a config flag. If it quant-checks out ‚Üí flip it on. If it sucks ‚Üí delete the module and remove the flag. Nothing else has to change.

I‚Äôll give you a Replit prompt that:
	‚Ä¢	Treats your current codebase as the ‚Äúcore engine‚Äù.
	‚Ä¢	Adds a VWAP mean-reversion strategy module that:
	‚Ä¢	Uses underlying VWAP deviation for signals.
	‚Ä¢	Outputs options trades only (debit spreads).
	‚Ä¢	Wires it into your engine via a feature flag like ENABLE_VWAP_MEANREV.
	‚Ä¢	Lets you backtest and disable without polluting the rest of the system.

‚∏ª

Replit prompt ‚Äì Add VWAP Mean-Reversion as a Pluggable Module

You can paste this into Replit for Ghostwriter/AI:

‚∏ª

PROMPT FOR REPLIT (EXTEND EXISTING SYSTEM)

You are an expert Python quant/architect.
You are working inside an existing options-only automated trading system that already:
	‚Ä¢	Has a core engine (strategy loop / scheduler).
	‚Ä¢	Has a way to define strategy modules (or at least can be refactored to one).
	‚Ä¢	Has an options execution layer (building spreads/flies, sending orders or logging paper trades).
	‚Ä¢	Has a backtest / paper-trade mode.

Your task:

üëâ Add a new VWAP intraday mean-reversion strategy as a self-contained module, wired through a config flag so it can be:
	‚Ä¢	Backtested in isolation or alongside existing strategies.
	‚Ä¢	Turned ON or OFF without breaking anything.
	‚Ä¢	Easily removed later if results are bad.

Do NOT rewrite the whole project.
Work with the existing architecture and patterns.

‚∏ª

1. Discover the existing strategy interface
	1.	Inspect the repo and identify:
	‚Ä¢	Where strategies are defined (e.g. strategies/, modules/).
	‚Ä¢	How strategies plug into the main engine.
Look for things like:
	‚Ä¢	BaseStrategy, Strategy, register_strategy, strategy_registry, etc.
	‚Ä¢	Or a central dispatch that routes market state to multiple strategies.
	2.	If there is already a base class / protocol for strategies, conform to it.
For example, something like:

class BaseStrategy(ABC):
    @abstractmethod
    def generate_signals(self, market_state, config) -> list[Signal]:
        ...

Or whatever equivalent exists.

	3.	If there is no clear strategy interface, create one minimal, backwards-compatible abstraction, and adapt existing strategies with very thin wrappers. Keep this minimal and non-breaking.

‚∏ª

2. Create the VWAP Mean-Reversion Strategy Module

Add a new file, e.g.:
	‚Ä¢	strategies/vwap_meanrev.py

Implement a class like:

class VWAPMeanReversionStrategy(BaseStrategy):
    def __init__(self, config, logger):
        self.config = config
        self.logger = logger

    def generate_signals(self, market_state) -> list[Signal]:
        ...

Where:
	‚Ä¢	market_state includes at least:
	‚Ä¢	symbol
	‚Ä¢	intraday 1m/5m bars for the current session
	‚Ä¢	daily ATR or recent volatility info
	‚Ä¢	session timestamps (09:30‚Äì16:00 NY)
	‚Ä¢	You can either:
	‚Ä¢	Re-use existing VWAP helpers if they exist, or
	‚Ä¢	Add a simple VWAP calculator.

Signal engine is UNDERLYING ONLY. No options inside this class.

‚∏ª

3. Signal Logic (UNDERLYING, as module-level behavior)

Implement the signal logic as follows (parameterized via config):
	1.	VWAP calculation
	‚Ä¢	For the current session (09:30‚Äì16:00), compute VWAP on 1-minute or 5-minute bars:
	‚Ä¢	Typical VWAP = cum(Price * Volume) / cum(Volume).
	2.	Daily ATR / regime
	‚Ä¢	Use existing daily data if available; otherwise compute a 20-day ATR for each symbol.
	‚Ä¢	Use ATR for scaling and regime filter.
	3.	Non-trend day filter
	‚Ä¢	For each symbol/session, decide if it‚Äôs eligible for mean-reversion.
	‚Ä¢	Use params (exposed in config):
	‚Ä¢	max_session_range_atr_frac
	‚Ä¢	max_open_to_high_atr_frac
	‚Ä¢	max_open_to_low_atr_frac
	‚Ä¢	trend_cutoff_time (e.g. ‚Äú11:00‚Äù).
	‚Ä¢	If:
	‚Ä¢	Session range or open-extension exceeds these ATR thresholds early in the day ‚Üí treat as trend day ‚Üí strategy OFF for that symbol/day.
	4.	Deviation + trigger (long side)
	‚Ä¢	Only look for trades between min_entry_time and max_entry_time (e.g. 10:00‚Äì15:30).
	‚Ä¢	Compute a distance band from VWAP based on ATR:

band = band_atr_frac * daily_atr


	‚Ä¢	Long setup:
	‚Ä¢	Condition A: price trades below VWAP ‚Äì band.
	‚Ä¢	Condition B: then a subsequent bar closes back up toward VWAP, e.g.:
	‚Ä¢	close_now > close_prev AND
	‚Ä¢	close_now > vwap_now - band.
	‚Ä¢	That bar is the trigger bar.
	‚Ä¢	Define:
	‚Ä¢	P       = trigger bar close.
	‚Ä¢	P_stop  = min(
recent swing low in this deviation leg,
vwap_now - 2 * band
)  (choose something simple + param).
	‚Ä¢	P_target = VWAP at trigger time.
	‚Ä¢	Create a Signal object (use the project‚Äôs existing Signal type if any):

Signal(
    strategy_name="VWAP_MEANREV",
    symbol=symbol,
    direction="LONG",
    entry_time=trigger_timestamp,
    P=P,
    P_stop=P_stop,
    P_target=P_target,
    meta={...}
)


	5.	Short setup (mirror):
	‚Ä¢	Condition A: price trades above VWAP + band.
	‚Ä¢	Condition B: next bar closes back down toward VWAP.
	‚Ä¢	P = trigger close; P_stop = local high or vwap + 2*band; P_target = VWAP.
	‚Ä¢	Direction "SHORT".
	6.	Per-day constraints:
	‚Ä¢	At most max_trades_per_day per symbol (configurable).
	‚Ä¢	Optionally enforce one direction per day (if needed).

All thresholds must come from config, e.g.:

strategies:
  vwap_meanrev:
    enabled: false
    band_atr_frac: 0.5
    max_session_range_atr_frac: 1.0
    max_open_to_high_atr_frac: 0.7
    max_open_to_low_atr_frac: 0.7
    min_entry_time: "10:00"
    max_entry_time: "15:30"
    max_trades_per_day: 1


‚∏ª

4. Map Signals ‚Üí Options Trades Using Existing Options Layer

You already have an options engine.
Do NOT re-invent it.
	1.	Find where underlying-level signals are translated into options positions:
	‚Ä¢	It might be something like build_options_trades_from_signal(signal, risk_config).
	2.	For VWAP_MEANREV signals, do debit spreads only:
	‚Ä¢	For direction="LONG":
	‚Ä¢	Use call debit spread, same-day or next-day expiry according to existing rules.
	‚Ä¢	K_long ‚âà closest strike to P.
	‚Ä¢	K_short ‚âà closest strike to P_target.
	‚Ä¢	For direction="SHORT":
	‚Ä¢	Use put debit spread:
	‚Ä¢	K_long ‚âà closest strike to P.
	‚Ä¢	K_short ‚âà closest strike to P_target.
	3.	Use your existing risk config:
	‚Ä¢	Per-trade risk cap as % of account or notional.
	‚Ä¢	Sizing based on debit (max loss).
	‚Ä¢	Daily loss limit still enforced by existing risk manager.
	4.	Exit:
	‚Ä¢	Re-use the framework‚Äôs existing exit logic (target hit, stop hit, time stop), but:
	‚Ä¢	P_target ‚Üí when underlying hits, close spread.
	‚Ä¢	P_stop   ‚Üí when underlying hits, treat as full invalidation and exit spread.
	‚Ä¢	If neither hit by your configured cutoff time ‚Üí close spread at market.

‚∏ª

5. Wire the Strategy via a Feature Flag
	1.	In the global config (YAML/JSON or whatever you use), add:

strategies:
  vwap_meanrev:
    enabled: false
    ...

	2.	In the main engine / strategy loader, modify the registry so:
	‚Ä¢	If strategies.vwap_meanrev.enabled is true, instantiate VWAPMeanReversionStrategy and register it.
	‚Ä¢	If false, do nothing; the rest of the engine runs as-is.
	3.	Make sure logging explicitly tags all logs from this module with strategy = VWAP_MEANREV.

‚∏ª

6. Backtest / Paper-Trade Hooks
	1.	Ensure the existing backtest runner can:
	‚Ä¢	Run with other strategies OFF, only VWAP_MEANREV ON.
	‚Ä¢	Run with VWAP_MEANREV + others (for portfolio impact).
	2.	Make sure:
	‚Ä¢	All VWAP_MEANREV trades are clearly labeled.
	‚Ä¢	Results can be filtered by strategy_name == "VWAP_MEANREV".
	3.	Add a small helper script if needed, e.g.:
	‚Ä¢	scripts/run_backtest_vwap_meanrev.py with:
	‚Ä¢	Enable only VWAP in config or override via CLI.
	‚Ä¢	Run for a given date range on SPY/QQQ.
	‚Ä¢	Dump results to CSV/Parquet.

‚∏ª

7. Safety and Clean Removal
	‚Ä¢	The VWAP module must be purely additive:
	‚Ä¢	No changes to the core engine behavior when enabled=false.
	‚Ä¢	No invasive modifications of unrelated strategies.
	‚Ä¢	If results are bad:
	‚Ä¢	We can remove vwap_meanrev.py.
	‚Ä¢	Remove its config block.
	‚Ä¢	Remove its registration line.
	‚Ä¢	Nothing else should break.

Keep the code:
	‚Ä¢	Well-commented.
	‚Ä¢	Contained in its own file.
	‚Ä¢	Using the existing abstractions and types (Signal, Trade, etc.) wherever possible.

‚∏ª

End of prompt. Build exactly this, integrated into the existing system.

‚∏ª

If you want next, I can help you define a simple acceptance test for this module: e.g., ‚Äúdon‚Äôt even consider turning it on live unless it hits X win rate, Y PF, Z max DD over 5+ years.‚Äù